

#' Bar Plots of Traits Values along a Phylogeny
#'
#' This function computes Local Indicator of Phylogenetic Association (local Moran's I) for each tip of the tree.
#' Tests are based on permutations.
#' 
#' @param p4d a phylo4d object (see Details).
#' @param trait the trait(s) in the p4d object to include in the plot.
#' Can be a character vector giving the name of the trait(s) or a single number giving the column index
#' in the table of the data slot of the p4d object. Can be used to reorder the traits in the plot.
#' @param center a logical indicating whether traits values should be centered.
#' @param scale a logical indicating whether traits values should be scaled.
#' 
#' @param tree.type a character string specifying the type of phylogeny to be drawn ("phylogram" or "cladogram").
#' @param tree.ratio a numeric value in [0, 1] giving the proportion of width of the figure for the tree.
#' @param tree.xlim a numeric vector of length 2 giving the limits of the x-axis for the tree. If \code{NULL},
#' it is determined automatically.
#' @param tree.open.angle a numeric value giving the angle in degrees left blank if \code{tree.type = "fan"}.
#' @param tree.open.crown a logical indicating whether the crowns should be drawn following the value
#' of \code{tree.open.angle} (default \code{TRUE}).
#' 
#' @param show.tip logical indicating whether tips labels should be drawn.
#' @param tip.labels character vector to label the tips.
#' If \code{NULL} the tips labels of the \code{phylo4d} object are used
#' @param tip.col a vector of R colors (code or name) to use for the tips labels.
#' Recycled if necessary.
#' @param tip.cex a numeric vector to control character size of the tips labels.
#' Recycled if necessary.
#' @param tip.font an integer vector specifying the type of font for the tips labels:
#' 1 (plain text), 2 (bold), 3 (italic), or 4 (bold italic). Recycled if necessary.
#' @param tip adj a vector of numeric in [0, 1] to control tips labels justification:
#' 0 (left-justification), 0.5 (centering), or 1 (right-justification). Recycled if necessary.
#' 
#' @param bar.xlim numeric vector of length 2 or matrix giving the x coordinates range for
#' the barplots (see Details).
#' @param bar.lwd a vector of numeric giving bar widths of the barplot(s).
#' Recycled along the tips, reapeated for each trait.
#' @param bar.col a vector of R colors (code or name) to use for the bars.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' @param show.bar.axis logical indicating whether barplots axes should be drawn.
#' 
#' @param dot.col a vector of R colors (code or name) to use for the points.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' @param dot.pch a numerical vector of symbol to use for the points.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' @param dot.cex a numerical vector. Character (or symbol) expansion for the points.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' 
#' @param cell.col a list of colors for 'gridplot' cells.
#' Easily generated by \code{heat.colors}, \code{topo.colors}, \code{terrain.colors}
#' or other functions created with \code{colorRampPalette}.
#' @param show.color.scale logical indicating whether color scale should be drawn.
#' 
#' @param show.trait logical indicating whether traits labels should be drawn.
#' @param trait.labels character vector to label the traits.
#' If \code{NULL} the traits labels of the \code{phylo4d} object are used.
#' @param trait.col a vector of R colors (code or name) to use for the traits labels.
#' Recycled if necessary.
#' @param trait.cex a numeric vector to control character size of the trait labels.
#' Recycled if necessary.
#' @param trait.font an integer vector specifying the type of font for the traits labels:
#' 1 (plain text), 2 (bold), 3 (italic), or 4 (bold italic). Recycled if necessary.
#' @param trait.bg.col a vector of R colors (code or name) to use for the background of the barplots.
#' Recycled if necessary.
#' 
#' @param error.bar.sup a matrix giving the superior limit for error bars.
#' Columns and rows names must match with traits and tips labels.
#' @param error.bar.inf a matrix giving the inferior limit for error bars.
#' Columns and rows names must match with traits and tips labels.
#' @param error.bar.col a vector of R colors (code or name) to draw error bars.
#' 
#' @param show.box a logical indicating whether a box should be drawn around the barplots.
#' @param grid.vertical a logical incating whether vertical lines of the grid should be drawn.
#' @param grid.horizontal a logical incating whether horizontal lines of the grid should be drawn.
#' @param grid.col a vector of R color(s) to use for the lines of the grid.
#' @param grid.lty the lines type of the grid. Possibly a vector.
#' @param further arguments to be passed to \code{plot.phylo}.
#'  
#' @export
multiplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE, plot.type = "barplot",
                     tree.type = "phylogram", tree.ratio = NULL, tree.xlim = NULL,
                     tree.open.angle = 0, tree.open.crown = TRUE,
                     show.tip = TRUE, tip.labels = NULL, tip.col = "black", tip.cex = 1, tip.font = 3, tip.adj = 0,
                     bar.xlim = NULL, bar.lwd = 10, bar.col = "grey35", show.bar.axis = TRUE,
                     dot.col = "black", dot.pch = 20, dot.cex = 2,
                     cell.col = white2red(100), show.color.scale = TRUE,
                     show.trait = TRUE, trait.labels = NULL, trait.col = "black", trait.cex = 1, trait.font = 1,
                     trait.bg.col = "grey90", error.bar.sup = NULL, error.bar.inf = NULL, error.bar.col = 1,
                     show.box = FALSE, grid.vertical = TRUE, grid.horizontal = FALSE, grid.col = "grey25",
                     grid.lty = "dashed", ...){

                      
  p4 <- extractTree(p4d)
  phy <- as(p4, "phylo")
  new.order <- phy$edge[, 2][!phy$edge[, 2] %in% phy$edge[, 1]]
  tips <- phy$tip.label[new.order]
  n.tips <- length(tips)
  X <- tdata(p4d, type = "tip")
  X <- X[new.order, trait]
  X <- scale(X, center = center, scale = scale)
  X <- as.data.frame(X)
  colnames(X) <- trait
  n.traits <- ncol(X)
  if(is.numeric(trait)){
    trait <- names(tdata(p4d))[trait]
  }
####
  tree.type <- match.arg(tree.type, c("phylogram", "cladogram", "fan"))
  plot.type <- match.arg(plot.type, c("barplot", "dotplot", "gridplot"))
  
  if(!is.null(error.bar.inf)){
    error.bar.inf <- as.matrix(error.bar.inf)
    error.bar.inf[is.na(error.bar.inf)] <- 0
    error.bar.inf <- matchTipsAndTraits(error.bar.inf, p4d.tips = tips, p4d.traits = trait)
  }
  if(!is.null(error.bar.sup)){
    error.bar.sup <- as.matrix(error.bar.sup)
    error.bar.sup[is.na(error.bar.sup)] <- 0
    error.bar.sup <- matchTipsAndTraits(error.bar.sup, p4d.tips = tips, p4d.traits = trait)
  }
  
  if(!is.null(error.bar.inf)){
    arrow.inf <- X
    arrow.inf[X>0] <- X[X>0] - error.bar.inf[X>0]
    arrow.inf[X<0] <- X[X<0] + error.bar.inf[X<0]
  }
  if(!is.null(error.bar.sup)){
    arrow.sup <- X
    arrow.sup[X>0] <- X[X>0] + error.bar.sup[X>0]
    arrow.sup[X<0] <- X[X<0] - error.bar.sup[X<0]
  }
  
  if(is.null(bar.xlim)){
    if(center & scale){
      bar.xlim <- matrix(rep(NA, n.traits * 2), nrow = 2,
                         dimnames = list(c("xlim.min", "xlim.max"), trait))
      if(!is.null(error.bar.inf) & !is.null(error.bar.sup)){
        bar.xlim[1, ] <- floor(min(arrow.inf, arrow.sup))
        bar.xlim[2, ] <- ceiling(max(arrow.inf, arrow.sup))
      } else if(!is.null(error.bar.inf)){
        bar.xlim[1, ] <- floor(min(arrow.inf))
        bar.xlim[2, ] <- ceiling(max(arrow.inf))
      } else if(!is.null(error.bar.sup)){
        bar.xlim[1, ] <- floor(min(arrow.sup))
        bar.xlim[2, ] <- ceiling(max(arrow.sup))
      } else {
        bar.xlim[1, ] <- floor(min(X))
        bar.xlim[2, ] <- ceiling(max(X))
      }
    } else {
      bar.xlim <- matrix(NA, nrow = 2, ncol = n.traits,
                         dimnames = list(c("xlim.min", "xlim.max"), trait))
      bar.xlim[1, ] <- apply(X, 2, min)
      bar.xlim[1, apply(X, 2, min) * apply(X, 2, max) > 0 & apply(X, 2, min) > 0] <- 0
      bar.xlim[2, ] <- apply(X, 2, max)
      bar.xlim[2, apply(X, 2, min) * apply(X, 2, max) > 0 & apply(X, 2, max) < 0] <- 0
      if(!is.null(error.bar.inf) & !is.null(error.bar.sup)){
        bar.xlim[1, ] <- apply(cbind(apply(arrow.inf, 2, min), apply(arrow.sup, 2, min)), 1, min)
        bar.xlim[2, ] <- apply(cbind(apply(arrow.inf, 2, max), apply(arrow.sup, 2, max)), 1, max)
      } else {
        if(!is.null(error.bar.inf)){
          bar.xlim[1, ] <- apply(cbind(apply(arrow.inf, 2, min), bar.xlim[1, ]), 1, min)
          bar.xlim[2, ] <- apply(cbind(apply(arrow.inf, 2, max), bar.xlim[2, ]), 1, max)
        }
        if(!is.null(error.bar.sup)){
          bar.xlim[1, ] <- apply(cbind(apply(arrow.sup, 2, min), bar.xlim[1, ]), 1, min)
          bar.xlim[2, ] <- apply(cbind(apply(arrow.sup, 2, max), bar.xlim[2, ]), 1, max)
        }
      }
    }
  } else if(is.vector(bar.xlim) & length(bar.xlim) == 2){
    bar.xlim <- matrix(rep(bar.xlim, n.traits), nrow = 2,
                       dimnames = list(c("xlim.min", "xlim.max"), trait))
  } else if(is.matrix(bar.xlim)){
    if(isTRUE(all.equal(dim(bar.xlim), c(2, n.traits)))){
      rownames(bar.xlim) <- c("xlim.min", "xlim.max")
      colnames(bar.xlim) <- trait
    } else{
      stop("Invalid 'bar.xlim' argument: wrong matrix dimensions")
    }
  } else {
    stop("Invalid 'bar.xlim' argument")
  }
  

  ylim <- c(1, n.tips)
  
  if(plot.type == "barplot"){
    bar.col <- orderGrArg(bar.col, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = "grey35")
  }
  
  if(plot.type == "dotplot"){

    dot.col <- orderGrArg(dot.col, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = 1)
    
    dot.pch <- orderGrArg(dot.pch, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = 1)
    
    dot.cex <- orderGrArg(dot.cex, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = 1)
    
  }
  

  if(is.null(tip.labels)){
    tip.labels <- tips
  } else {
    tip.labels <- orderGrArg(tip.labels, n.tips = n.tips, n.traits = n.traits,
                             new.order = new.order, tips = tips, default = "")
  }
  tip.col <- orderGrArg(tip.col, n.tips = n.tips, n.traits = n.traits,
                        new.order = new.order, tips = tips, default = 1)
  tip.cex <- orderGrArg(tip.cex, n.tips = n.tips, n.traits = n.traits,
                        new.order = new.order, tips = tips, default = 1)
  tip.font <- orderGrArg(tip.font, n.tips = n.tips, n.traits = n.traits,
                         new.order = new.order, tips = tips, default = 3)

  
  
  if(is.null(trait.labels)){
    trait.labels <- trait
  }
  trait.labels <- rep(trait.labels, length.out = n.traits)
  trait.col <- rep(trait.col, length.out = n.traits)
  trait.cex <- rep(trait.cex, length.out = n.traits)
  trait.font <- rep(trait.font, length.out = n.traits)
  trait.bg.col <- rep(trait.bg.col, length.out = n.traits)
  
  if(is.null(tree.xlim)){
    tree.xlim <- plotPhyloDisabled(phy, type = tree.type,
                                   show.tip.label = FALSE,
                                   x.lim = NULL, y.lim = NULL,
                                   no.margin = FALSE, direction = "rightwards",
                                   plot = FALSE, ...)$x.lim
  }
  
  ###
  par.mar0 <- par("mar")
  par.lend0 <- par("lend")
  par.xpd0 <- par("xpd")
  
  if(tree.type == "phylogram" | tree.type == "cladogram"){
    
    if(plot.type %in% c("barplot", "dotplot")){
      lay <- layouterize(n.traits = n.traits, show.tip = show.tip)
      lay.w <- layouterizeRatio(tree.ratio = tree.ratio, n.traits = n.traits, show.tip = show.tip)
    }
    if(plot.type == "gridplot"){
      lay <- layouterize(n.traits = 1, show.tip = show.tip)
      lay.w <- layouterizeRatio(tree.ratio = tree.ratio, n.traits = 1, show.tip = show.tip)
    }
    
    layout(lay, widths = lay.w)
    par(xpd = FALSE, mar=c(5, 1, 4, 0), lend = 1)
    fig.traits <- vector("list", n.traits)
    names(fig.traits) <- trait
    
    if(plot.type %in% c("barplot", "dotplot")){
      for(i in 1:n.traits){
        plot.new()
        plot.window(xlim = bar.xlim[, i], ylim = ylim)
        fig.traits[[i]] <- par("fig")
        rect(par("usr")[1], par("usr")[3]-(3 * par("cxy")[2]), par("usr")[2], par("usr")[4],
             col = trait.bg.col[i], border = NA, xpd = TRUE)
        if(show.box){
          box()
        }
        if(grid.vertical){        
          grid(NULL, NA, col = grid.col, lty = grid.lty)
          abline(v = 0, lty = "solid", col = grid.col)
        } else {
          abline(v = 0, lty = "solid", col = grid.col)
        }
        if(grid.horizontal){
          abline(h= 1:n.tips, col = grid.col, lty = grid.lty)
        }
        if(plot.type == "barplot"){
          segments(x0 = 0, x1 = X[, i], y0 = 1:n.tips, lwd = bar.lwd, col = bar.col[, i])
        }
        if(plot.type == "dotplot"){
          points(x = X[, i], y = 1:n.tips, col = dot.col[, i], pch= dot.pch[, i], cex = dot.cex[, i])
        }
        options(warn = -1)
        if(!is.null(error.bar.inf)){
          arrows(x0 = X[, i], x1 = arrow.inf[, i], y0 = 1:n.tips,
                 lwd = 1, col = error.bar.col, angle = 90, length = 0.04)
        }
        if(!is.null(error.bar.sup)){
            arrows(x0 = X[, i], x1 = arrow.sup[, i], y0 = 1:n.tips,
                 lwd = 1, col = error.bar.col, angle = 90, length = 0.04)
        }
        options(warn = 1)
        if(show.bar.axis){
          axis(1)
        }
        if(show.trait){
          mtext(trait.labels[i], side = 1, line = 3, las = par("las"),
                col = trait.col[i], cex = trait.cex[i],
                font = trait.font[i])
        }
      }
    }
    if(plot.type == "gridplot"){
      plot.new()
      rect(par("usr")[1], par("usr")[3] - (3 * par("cxy")[2]), par("usr")[2], par("usr")[4],
           col = trait.bg.col[1], border = NA, xpd = TRUE)
      bar.xlim[1, ] <- 0
      bar.xlim[2, ] <- n.traits
      plot.window(xlim = bar.xlim[, 1], ylim = ylim)
      fig.traits[[1]] <- par("fig")
      image(x = 0:n.traits, y = 1:n.tips, z = t(X),
            col = cell.col, add = TRUE,
            xlab = "", ylab = "", yaxs = FALSE, xaxs = FALSE)
      
      if(show.box){
        box()
      }
      
      if(grid.horizontal){        
        abline(h = seq(1.5, n.tips - 0.5), col = grid.col, lty = grid.lty)
      }
      if(grid.vertical){
        abline(v = seq(1, n.traits - 1), col = grid.col, lty = grid.lty)
      }
  
      if(show.trait){
        mtext(trait.labels, at = seq(0.5, (n.traits - 0.5)),
              side = 1, line = 1, las = par("las"),
              col = trait.col, cex = trait.cex,
              font = trait.font)    
      }
    }
    
    if(show.tip){
      plot.new()
      tip.xlim <- c(-1, 1)
      if(tip.adj < 0.5) tip.xlim[1] <- -tip.adj / 0.5
      if(tip.adj > 0.5) tip.xlim[2] <- -2 * tip.adj + 2
      plot.window(xlim = tip.xlim, ylim = ylim)
      text(x = 0, y = 1:n.tips, labels = tip.labels,
           adj = tip.adj, col = tip.col, cex = tip.cex, font = tip.font)
      fig.tip <- par("fig")
    } else {
      fig.tip <- NULL
      tip.xlim <- NULL
    }
    
    plot.phylo(phy, type = tree.type, show.tip.label = FALSE,
               x.lim = tree.xlim, y.lim = NULL,
               no.margin = FALSE, direction = "rightwards", ...)
    fig.tree <- par("fig")
    
    if(plot.type == "gridplot" & show.color.scale){
      par(new = TRUE)
      plt.init <- par("plt")
      par(plt = c(par("plt")[1] + 0.05, par("plt")[2] - 0.2, 0.07, 0.1))
      plot.new()
      breaks <- seq(min(X), max(X), length.out = (length(cell.col) + 1))
      scale.xlim <- range(breaks)
      scale.ylim <- c(0, 1)
      plot.window(xlim = scale.xlim, ylim = scale.ylim)
      for(i in 1:length(cell.col)){
        polygon(c(breaks[i], breaks[i + 1], breaks[i + 1], breaks[i]), c(0, 0, 1, 1),
                col = cell.col[i], border = NA)
      }
      axis(1)
      par(plt = plt.init)
    }
    
    assign("last_barplotp4d", list(plot.type = plot.type,
                                   show.tip = show.tip,
                                   layout = lay,
                                   fig.tree = fig.tree,
                                   fig.traits = fig.traits,
                                   fig.tip = fig.tip,
                                   tree.xlim = tree.xlim,
                                   bar.xlim = bar.xlim,
                                   tip.xlim = tip.xlim,
                                   ylim = ylim, par.mar0 = par.mar0), 
           envir = .PlotPhyloEnv)
    layout(1)
  }
  

  if(tree.type == "fan"){
    par(lend = 1)
    if(is.null(tree.ratio)){
      if(show.tip){
        tree.ratio <- 1 / (n.traits + 2)
      } else {
        tree.ratio <- 1 / (n.traits + 1)
      }
    }
    
    plot.phylo(phy, type = tree.type, show.tip.label = FALSE,
               x.lim = tree.xlim * (1/tree.ratio), y.lim = NULL,
               no.margin = TRUE, open.angle = tree.open.angle, rotate.tree = 0, ...)
    lp <- get("last_plot.phylo", envir = .PlotPhyloEnv)
        
    length.phylo <- sqrt(lp$xx[1]^2 + lp$yy[1]^2)
    if(show.tip){
      length.gr0 <- (min(par("usr")[2] - par("usr")[1], par("usr")[4] - par("usr")[3]) / 2 - length.phylo) / (n.traits+1)
    } else {
      length.gr0 <- (min(par("usr")[2] - par("usr")[1], par("usr")[4] - par("usr")[3]) / 2 - length.phylo) / n.traits
    }
    length.intergr <- 0.2 * length.gr0
    length.gr <- length.gr0 - length.intergr
    
    theta <- atan2(lp$xx[1:n.tips], lp$yy[1:n.tips])[new.order]
    cos.t <- cos(pi/2 - theta)
    sin.t <- sin(pi/2 - theta)
    
    if(tree.open.crown){
      theta.soft <- pi/2 - seq(0, 360 - tree.open.angle) * pi/180 + 10 * pi/180
    } else {
      theta.soft <- pi/2 - seq(0, 360) * pi/180 + 10 * pi/180
    }
    cos.tsoft <- cos(pi/2 - theta.soft)
    sin.tsoft <- sin(pi/2 - theta.soft)
    
    for(i in 1:n.traits){
      # RINGS
      length.ring1 <- length.phylo + length.intergr*i + length.gr*(i-1) - 0.3*length.intergr
      length.ring2 <- length.phylo + length.intergr*i + length.gr*i + 0.3*length.intergr
      xx1 <- length.ring1 * cos.tsoft
      xx2 <- length.ring2 * cos.tsoft
      yy1 <- length.ring1 * sin.tsoft
      yy2 <- length.ring2 * sin.tsoft
      polygon(c(xx1, rev(xx2)), c(yy1, rev(yy2)), col = trait.bg.col[i], border = NA)
      if(show.box){
        if(tree.open.crown){
          lines(c(xx1, rev(xx2)), c(yy1, rev(yy2)), col = 1)
        } else {
          lines(xx1, yy1, col = 1)
          lines(xx2, yy2, col = 1)          
        } 
      }
      
      
      # SCALING VALUES
      if(abs(sign(min(X[, i])) + sign(max(X[, i]))) == 2){
        X.scale <- X[, i] * length.gr / max(abs(min(X[, i])), abs(max(X[, i])))
      } else {
        X.scale <- X[, i] * length.gr / diff(c(min(X[, i]), max(X[, i])))
      }
      
      # BASELINE AND VALUES
      length.baseline <- (length.phylo + length.intergr*i + length.gr*(i-1) +
                          ifelse(min(X.scale) < 0, abs(min(X.scale)), 0))
      length.baseline <- rep(length.baseline, n.tips)
      length.values <- length.baseline + X.scale
      
      #Grid Species
      if(grid.horizontal){
        segments(x0 = length.ring1 * cos.t,
                 x1 = length.ring2 * cos.t,
                 y0 = length.ring1 * sin.t,
                 y1 = length.ring2 * sin.t,
                 col = grid.col, lty = grid.lty)
      }
      
      # Axe and circular grid
      if(show.bar.axis | grid.vertical){
        if(tree.open.crown){
          theta.ax <- theta.soft[1]
        } else {
          theta.ax <-theta.soft[1] + tree.open.angle/2 * pi/180
        }
        cos.tax <- cos(pi/2 - theta.ax)
        sin.tax <- sin(pi/2 - theta.ax)
        nint.ticks <- round((length.gr / min(par("usr")[2] - par("usr")[1], par("usr")[4] - par("usr")[3]))/3 *100) - 1
        if(min(X.scale) <= 0 & max(X.scale) >=0){
          ticks <- axisTicks(c(min(X.scale), max(X.scale)), log = FALSE, nint = nint.ticks)
        } else {
          if(abs(min(X.scale)) > max(X.scale)){
            ticks <- axisTicks(c(0, min(X.scale)), log = FALSE, nint = nint.ticks)
          } else {
            ticks <- axisTicks(c(0, max(X.scale)), log = FALSE, nint = nint.ticks)
          }
        }
        
        length.ticks <- length.baseline[1] + ticks
        
        # Grid Axis values
        if(grid.vertical){
          for(j in 1:length(length.ticks)){
            lines(length.ticks[j] * cos.tsoft,
                  length.ticks[j] * sin.tsoft,
                  col = grid.col, lty = grid.lty)
          }
        }
        
        if(show.bar.axis){
          # Frame for axis values
          segments(x0 = length.ring1 * cos.tax,
                   x1 = length.ring2 * cos.tax,
                   y0 = length.ring1 * sin.tax,
                   y1 = length.ring2 * sin.tax,
                   lwd = 20, col = trait.bg.col[i])
          
          # Axis Values
          text(x = length.ticks * cos.tax, 
               y = length.ticks * sin.tax,
               labels = ticks, cex = tip.cex)
        }
      }
      
      # Draw Bars
      segments(x0 = length.baseline * cos.t,
               x1 = length.values * cos.t,
               y0 = length.baseline * sin.t,
               y1 = length.values * sin.t,
               lwd = bar.lwd, col = bar.col[, i])
      # Draw Baseline
      length.baseline <- rep(length.baseline, length.out = length(cos.tsoft))
      lines(length.baseline * cos.tsoft, length.baseline * sin.tsoft, lwd = 1)
    }
    
    if(show.tip){
      
      length.tipsline <- (length.phylo+length.intergr*(n.traits+1)+length.gr*(n.traits))
      tip.xlim <- c(-1, 1)
      if(tip.adj < 0.5) tip.xlim[1] <- -tip.adj / 0.5
      if(tip.adj > 0.5) tip.xlim[2] <- -2 * tip.adj + 2
      
      for(i in 1:n.tips){
        if(theta[i] > 0){
          text(x = length.tipsline * cos.t[i],
               y = length.tipsline * sin.t[i],
               labels = tip.labels[i],
               adj = 0, col = tip.col[i], cex = tip.cex[i], font = tip.font[i],
               srt = (pi/2-theta[i]) * 180 /pi)
        } else {
          text(x = length.tipsline * cos.t[i],
               y = length.tipsline * sin.t[i],
               labels = tip.labels[i],
               adj = 1, col = tip.col[i], cex = tip.cex[i], font = tip.font[i],
               srt = (-pi/2-theta[i]) * 180 /pi)
        }
      }
    }
    
  }
  
  par(mar = par.mar0, xpd = par.xpd0, lend = par.lend0)
  invisible()
}



#' Focus on sub parts of a plot
#'
#' These functions can be used after barplot.phylo4d to focus on
#' the different part of the plot and add graphical elements.
#' 
#' @param x the trait to focus on.
#' Can be a character string giving the name of the trait or an integer giving
#' the number of the trait in order of appearance in the plot.
#' 
#' @details #' Use \code{focusTree} to focus on the phylogenetic tree, \code{focusTraits}
#' to focus on a given trait and \code{focusTips} to focus on the tips labels.
#' Use \code{focusStop} to close the editing and restore graphical settings.
#' For each part of the plot, the coordinate system is restored, making edition easier.
#' For the phylogeny, post-editing functions of the package \code{ape} like \code{nodelabels} can be used.
#'
#'@rdname focus
#'@export
focusTraits <- function(x){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  if(lp$plot.type == "gridplot"){
    x <- 1
  }
  par(new = TRUE)
  plot.new()
  layout(lp$layout)
  par(mar = c(5, 1, 4, 0))
  fig <- unlist(lp$fig.traits[x])
  par(fig = fig)
  plot.window(xlim = lp$bar.xlim[, x], ylim = lp$ylim)
}

#'@rdname focus
#'@export
focusTree <- function(){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  par(new = TRUE)
  plot.new()
  layout(lp$layout)
  par(mar = c(5, 1, 4, 0))
  fig <- unlist(lp$fig.tree)
  par(fig = fig)
  plot.window(xlim = lp$tree.xlim, ylim = lp$ylim)
}

#'@rdname focus
#'@export
focusTips <- function(){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  if(!lp$show.tip){
    stop("No tip labels on the figure")
  } else {
    par(new = TRUE)
    plot.new()
    layout(lp$layout)
    par(mar = c(5, 1, 4, 0))
    fig <- unlist(lp$fig.tip)
    par(fig = fig)
    plot.window(xlim = lp$tip.xlim, ylim = lp$ylim)
  }
}

#'@rdname focus
#'@export
focusStop <- function(){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  layout(1)
  par(mar = lp$par.mar0)
}

#' Plot p4d Object
#'@export
#'@rdname plotp4d
barplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE, ...){
  
  multiplot.phylo4d(p4d, trait = trait, center = center, scale = scale, plot.type = "barplot", ...)
  
}


#'@rdname plotp4d
dotplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE,
                            grid.horizontal = TRUE, grid.vertical = FALSE, ...){
  
  multiplot.phylo4d(p4d, trait = trait, center = center, scale = scale, plot.type = "dotplot",
                    grid.horizontal = grid.horizontal, grid.vertical = grid.vertical, ...)
  
}


#'@rdname plotp4d
gridplot <- function(...){
  UseMethod("gridplot")
}
gridplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE,
                     grid.vertical = FALSE, trait.cex = 0.7, ...){
  
  multiplot.phylo4d(p4d, trait = trait, center = center, scale = scale, plot.type = "gridplot",
                    trait.cex = trait.cex, grid.vertical = grid.vertical, ...)
  
}


#    barplot(p4d, c("random","bm"), show.tip=T, tip.col=c(2,1), tip.cex=0.8, tip.font=1, tip.adj=0.5,
#   trait.col=c(2,3), trait.cex=0.8, trait.font=2, trait.bg.col="grey95" , error.bar.inf=mat.e, error.bar.sup=mat.e)

#    barplot(p4d, bar.col=matrix(c(rainbow(19), terrain.colors(19), heat.colors(19))))

#barplot(p4d, error.bar.inf=mat.e)

# mat.e <- matrix(abs(rnorm(19*3, 0, 0.5)), ncol=3, dimnames=list(tipLabels(p4d), names(tdata(p4d))))

# barplot(p4d, trait.bg.col = c("#F6CED8", "#CED8F6", "#CEF6CE"), bar.col = mat.col, tip.col=tip.col,
# grid.col=1:3, edge.width=2, lend=3, show.bar.axis=T, grid.horizontal=T, scale=F)
# focusTraits("random")
# points(0, 13, col =2, pch=20, cex=4)
# focusTips()
# points(0, 2, col= 3, cex= 3)
# abline(v=0.5, col=4)
# focusTree()
# points(2,3)
# nodelabels()
# focusStop()
# plot(1)