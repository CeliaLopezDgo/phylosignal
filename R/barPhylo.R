

#' Bar Plots of Traits Values along a Phylogeny
#'
#' This function computes Local Indicator of Phylogenetic Association (local Moran's I) for each tip of the tree.
#' Tests are based on permutations.
#' 
#' @param p4d a phylo4d object (see Details).
#' @param trait the trait(s) in the p4d object to include in the plot.
#' Can be a character vector giving the name of the trait(s) or a single number giving the column index
#' in the table of the data slot of the p4d object. Can be used to reorder the traits in the plot.
#' @param center a logical indicating whether traits values should be centered.
#' @param scale a logical indicating whether traits values should be scaled.
#' 
#' @param tree.type a character string specifying the type of phylogeny to be drawn ("phylogram" or "cladogram").
#' @param tree.ratio a numeric value in [0, 1] giving the proportion of width of the figure for the tree.
#' @param tree.xlim a numeric vector of length 2 giving the limits of the x-axis for the tree. If \code{NULL},
#' it is determined automatically.
#' 
#' @param show.tip logical indicating whether tips labels should be drawn.
#' @param tip.labels character vector to label the tips.
#' If \code{NULL} the tips labels of the \code{phylo4d} object are used
#' @param tip.col a vector of R colors (code or name) to use for the tips labels.
#' Recycled if necessary.
#' @param tip.cex a numeric vector to control character size of the tips labels.
#' Recycled if necessary.
#' @param tip.font an integer vector specifying the type of font for the tips labels:
#' 1 (plain text), 2 (bold), 3 (italic), or 4 (bold italic). Recycled if necessary.
#' @param tip adj a vector of numeric in [0, 1] to control tips labels justification:
#' 0 (left-justification), 0.5 (centering), or 1 (right-justification). Recycled if necessary.
#' 
#' @param bar.xlim numeric vector of length 2 or matrix giving the x coordinates range for
#' the barplots (see Details).
#' @param bar.lwd a vector of numeric giving bar widths of the barplot(s).
#' Recycled along the tips, reapeated for each trait.
#' @param bar.col a vector of R colors (code or name) to use for the bars.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' @param show.bar.axis logical indicating whether barplots axes should be drawn.
#' 
#' @param dot.col a vector of R colors (code or name) to use for the points.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' @param dot.pch a numerical vector of symbol to use for the points.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' @param dot.cex a numerical vector. Character (or symbol) expansion for the points.
#' Recycled along the tips, reapeated for each trait.
#' The user can also provide a matrix for a finer tuning (see Details)
#' 
#' @param cell.col a list of colors for 'gridplot' cells.
#' Easily generated by \code{heat.colors}, \code{topo.colors}, \code{terrain.colors}
#' or other functions created with \code{colorRampPalette}.
#' @param show.color.scale logical indicating whether color scale should be drawn.
#' 
#' @param show.trait logical indicating whether traits labels should be drawn.
#' @param trait.labels character vector to label the traits.
#' If \code{NULL} the traits labels of the \code{phylo4d} object are used.
#' @param trait.col a vector of R colors (code or name) to use for the traits labels.
#' Recycled if necessary.
#' @param trait.cex a numeric vector to control character size of the trait labels.
#' Recycled if necessary.
#' @param trait.font an integer vector specifying the type of font for the traits labels:
#' 1 (plain text), 2 (bold), 3 (italic), or 4 (bold italic). Recycled if necessary.
#' @param trait.bg.col a vector of R colors (code or name) to use for the background of the barplots.
#' Recycled if necessary.
#' @param error.bar.sup a matrix giving the superior limit for error bars.
#' Columns and rows names must match with traits and tips labels.
#' @param error.bar.inf a matrix giving the inferior limit for error bars.
#' Columns and rows names must match with traits and tips labels.
#' @param error.bar.col a vector of R colors (code or name) to draw error bars.
#' 
#' @param show.box a logical indicating whether a box should be drawn around the barplots.
#' @param grid.vertical a logical incating whether vertical lines of the grid should be drawn.
#' @param grid.horizontal a logical incating whether horizontal lines of the grid should be drawn.
#' @param grid.col a vector of R color(s) to use for the lines of the grid.
#' @param grid.lty the lines type of the grid. Possibly a vector.
#' @param further arguments to be passed to \code{plot.phylo}.
#'  
#' @export
multiplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE, plot.type = "barplot",
                     tree.type = "phylogram", tree.ratio = NULL, tree.xlim = NULL,
                     show.tip = TRUE, tip.labels = NULL, tip.col = "black", tip.cex = 1, tip.font = 3, tip.adj = 0,
                     bar.xlim = NULL, bar.lwd = 10, bar.col = "grey35", show.bar.axis = TRUE,
                     dot.col = "black", dot.pch = 20, dot.cex = 2,
                     cell.col = white2red(100), show.color.scale = TRUE,
                     show.trait = TRUE, trait.labels = NULL, trait.col = "black", trait.cex = 1, trait.font = 1,
                     trait.bg.col = "grey90", error.bar.sup = NULL, error.bar.inf = NULL, error.bar.col = 1,
                     show.box = FALSE, grid.vertical = TRUE, grid.horizontal = FALSE, grid.col = "grey25",
                     grid.lty = "dashed", ...){

                      
  p4 <- extractTree(p4d)
  phy <- as(p4, "phylo")
  new.order <- phy$edge[, 2][!phy$edge[, 2] %in% phy$edge[, 1]]
  tips <- phy$tip.label[new.order]
  n.tips <- length(tips)
  X <- tdata(p4d, type = "tip")
  X <- X[new.order, trait]
  X <- scale(X, center = center, scale = scale)
  X <- as.data.frame(X)
  colnames(X) <- trait
  n.traits <- ncol(X)
  if(is.numeric(trait)){
    trait <- names(tdata(p4d))[trait]
  }
####
  tree.type <- match.arg(tree.type, c("phylogram", "cladogram"))
  plot.type <- match.arg(plot.type, c("barplot", "dotplot", "gridplot"))
  
  if(!is.null(error.bar.inf)){
    error.bar.inf <- as.matrix(error.bar.inf)
    error.bar.inf[is.na(error.bar.inf)] <- 0
    error.bar.inf <- matchTipsAndTraits(error.bar.inf, p4d.tips = tips, p4d.traits = trait)
  }
  if(!is.null(error.bar.sup)){
    error.bar.sup <- as.matrix(error.bar.sup)
    error.bar.sup[is.na(error.bar.sup)] <- 0
    error.bar.sup <- matchTipsAndTraits(error.bar.sup, p4d.tips = tips, p4d.traits = trait)
  }
  
  if(!is.null(error.bar.inf)){
    arrow.inf <- X
    arrow.inf[X>0] <- X[X>0] - error.bar.inf[X>0]
    arrow.inf[X<0] <- X[X<0] + error.bar.inf[X<0]
  }
  if(!is.null(error.bar.sup)){
    arrow.sup <- X
    arrow.sup[X>0] <- X[X>0] + error.bar.sup[X>0]
    arrow.sup[X<0] <- X[X<0] - error.bar.sup[X<0]
  }
  
  if(is.null(bar.xlim)){
    if(center & scale){
      bar.xlim <- matrix(rep(NA, n.traits * 2), nrow = 2,
                         dimnames = list(c("xlim.min", "xlim.max"), trait))
      if(!is.null(error.bar.inf) & !is.null(error.bar.sup)){
        bar.xlim[1, ] <- floor(min(arrow.inf, arrow.sup))
        bar.xlim[2, ] <- ceiling(max(arrow.inf, arrow.sup))
      } else if(!is.null(error.bar.inf)){
        bar.xlim[1, ] <- floor(min(arrow.inf))
        bar.xlim[2, ] <- ceiling(max(arrow.inf))
      } else if(!is.null(error.bar.sup)){
        bar.xlim[1, ] <- floor(min(arrow.sup))
        bar.xlim[2, ] <- ceiling(max(arrow.sup))
      } else {
        bar.xlim[1, ] <- floor(min(X))
        bar.xlim[2, ] <- ceiling(max(X))
      }
    } else {
      bar.xlim <- matrix(NA, nrow = 2, ncol = n.traits,
                         dimnames = list(c("xlim.min", "xlim.max"), trait))
      bar.xlim[1, ] <- apply(X, 2, min)
      bar.xlim[1, apply(X, 2, min) * apply(X, 2, max) > 0 & apply(X, 2, min) > 0] <- 0
      bar.xlim[2, ] <- apply(X, 2, max)
      bar.xlim[2, apply(X, 2, min) * apply(X, 2, max) > 0 & apply(X, 2, max) < 0] <- 0
      if(!is.null(error.bar.inf) & !is.null(error.bar.sup)){
        bar.xlim[1, ] <- apply(cbind(apply(arrow.inf, 2, min), apply(arrow.sup, 2, min)), 1, min)
        bar.xlim[2, ] <- apply(cbind(apply(arrow.inf, 2, max), apply(arrow.sup, 2, max)), 1, max)
      } else {
        if(!is.null(error.bar.inf)){
          bar.xlim[1, ] <- apply(cbind(apply(arrow.inf, 2, min), bar.xlim[1, ]), 1, min)
          bar.xlim[2, ] <- apply(cbind(apply(arrow.inf, 2, max), bar.xlim[2, ]), 1, max)
        }
        if(!is.null(error.bar.sup)){
          bar.xlim[1, ] <- apply(cbind(apply(arrow.sup, 2, min), bar.xlim[1, ]), 1, min)
          bar.xlim[2, ] <- apply(cbind(apply(arrow.sup, 2, max), bar.xlim[2, ]), 1, max)
        }
      }
    }
  } else if(is.vector(bar.xlim) & length(bar.xlim) == 2){
    bar.xlim <- matrix(rep(bar.xlim, n.traits), nrow = 2,
                       dimnames = list(c("xlim.min", "xlim.max"), trait))
  } else if(is.matrix(bar.xlim)){
    if(isTRUE(all.equal(dim(bar.xlim), c(2, n.traits)))){
      rownames(bar.xlim) <- c("xlim.min", "xlim.max")
      colnames(bar.xlim) <- trait
    } else{
      stop("Invalid 'bar.xlim' argument: wrong matrix dimensions")
    }
  } else {
    stop("Invalid 'bar.xlim' argument")
  }
  

  ylim <- c(1, n.tips)
  
  if(plot.type == "barplot"){
    bar.col <- orderGrArg(bar.col, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = "grey35")
  }
  
  if(plot.type == "dotplot"){

    dot.col <- orderGrArg(dot.col, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = 1)
    
    dot.pch <- orderGrArg(dot.pch, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = 1)
    
    dot.cex <- orderGrArg(dot.cex, n.tips = n.tips, n.traits = n.traits,
                          new.order = new.order, tips = tips, default = 1)
    
  }
  

  if(is.null(tip.labels)){
    tip.labels <- tips
  } else {
    tip.labels <- orderGrArg(tip.labels, n.tips = n.tips, n.traits = n.traits,
                             new.order = new.order, tips = tips, default = "")
  }
  tip.col <- orderGrArg(tip.col, n.tips = n.tips, n.traits = n.traits,
                        new.order = new.order, tips = tips, default = 1)
  tip.cex <- orderGrArg(tip.cex, n.tips = n.tips, n.traits = n.traits,
                        new.order = new.order, tips = tips, default = 1)
  tip.font <- orderGrArg(tip.font, n.tips = n.tips, n.traits = n.traits,
                         new.order = new.order, tips = tips, default = 3)

  
  
  if(is.null(trait.labels)){
    trait.labels <- trait
  }
  trait.labels <- rep(trait.labels, length.out = n.traits)
  trait.col <- rep(trait.col, length.out = n.traits)
  trait.cex <- rep(trait.cex, length.out = n.traits)
  trait.font <- rep(trait.font, length.out = n.traits)
  trait.bg.col <- rep(trait.bg.col, length.out = n.traits)
  
  ###
  
  if(plot.type %in% c("barplot", "dotplot")){
    lay <- layouterize(n.traits = n.traits, show.tip = show.tip)
    lay.w <- layouterizeRatio(tree.ratio = tree.ratio, n.traits = n.traits, show.tip = show.tip)
  }
  if(plot.type == "gridplot"){
    lay <- layouterize(n.traits = 1, show.tip = show.tip)
    lay.w <- layouterizeRatio(tree.ratio = tree.ratio, n.traits = 1, show.tip = show.tip)
  }
  

  if(is.null(tree.xlim)){
   tree.xlim <- plotPhyloDisabled(phy, type = tree.type,
                                  show.tip.label = FALSE,
                                  x.lim = NULL, y.lim = NULL,
                                  no.margin = FALSE, direction = "rightwards",
                                  plot = FALSE, ...)$x.lim
  }
  
  layout(lay, widths = lay.w)
  par(xpd = FALSE)
  par.mar0 <- par("mar")
  par(mar=c(5, 1, 4, 0), lend = 1)
  fig.traits <- vector("list", n.traits)
  names(fig.traits) <- trait
  
  if(plot.type %in% c("barplot", "dotplot")){
    for(i in 1:n.traits){
      plot.new()
      plot.window(xlim = bar.xlim[, i], ylim = ylim)
      fig.traits[[i]] <- par("fig")
      rect(par("usr")[1], par("usr")[3]-(3 * par("cxy")[2]), par("usr")[2], par("usr")[4],
           col = trait.bg.col[i], border = NA, xpd = TRUE)
      if(show.box){
        box()
      }
      if(grid.vertical){        
        grid(NULL, NA, col = grid.col, lty = grid.lty)
        abline(v = 0, lty = "solid", col = grid.col)
      } else {
        abline(v = 0, lty = "solid", col = grid.col)
      }
      if(grid.horizontal){
        abline(h= 1:n.tips, col = grid.col, lty = grid.lty)
      }
      if(plot.type == "barplot"){
        segments(x0 = 0, x1 = X[, i], y0 = 1:n.tips, lwd = bar.lwd, col = bar.col[, i])
      }
      if(plot.type == "dotplot"){
        points(x = X[, i], y = 1:n.tips, col = dot.col[, i], pch= dot.pch[, i], cex = dot.cex[, i])
      }
      options(warn = -1)
      if(!is.null(error.bar.inf)){
        arrows(x0 = X[, i], x1 = arrow.inf[, i], y0 = 1:n.tips,
               lwd = 1, col = error.bar.col, angle = 90, length = 0.04)
      }
      if(!is.null(error.bar.sup)){
          arrows(x0 = X[, i], x1 = arrow.sup[, i], y0 = 1:n.tips,
               lwd = 1, col = error.bar.col, angle = 90, length = 0.04)
      }
      options(warn = 1)
      if(show.bar.axis){
        axis(1)
      }
      if(show.trait){
        mtext(trait.labels[i], side = 1, line = 3, las = par("las"),
              col = trait.col[i], cex = trait.cex[i],
              font = trait.font[i])
      }
    }
  }
  if(plot.type == "gridplot"){
    plot.new()
    rect(par("usr")[1], par("usr")[3] - (3 * par("cxy")[2]), par("usr")[2], par("usr")[4],
         col = trait.bg.col[1], border = NA, xpd = TRUE)
    bar.xlim[1, ] <- 0
    bar.xlim[2, ] <- n.traits
    plot.window(xlim = bar.xlim[, 1], ylim = ylim)
    fig.traits[[1]] <- par("fig")
    image(x = 0:n.traits, y = 1:n.tips, z = t(X),
          col = cell.col, add = TRUE,
          xlab = "", ylab = "", yaxs = FALSE, xaxs = FALSE)
    
    if(show.box){
      box()
    }
    
    if(grid.horizontal){        
      abline(h = seq(1.5, n.tips - 0.5), col = grid.col, lty = grid.lty)
    }
    if(grid.vertical){
      abline(v = seq(1, n.traits - 1), col = grid.col, lty = grid.lty)
    }

    if(show.trait){
      mtext(trait.labels, at = seq(0.5, (n.traits - 0.5)),
            side = 1, line = 1, las = par("las"),
            col = trait.col, cex = trait.cex,
            font = trait.font)    
    }
  }
  

  if(show.tip){
    plot.new()
    tip.xlim <- c(-1, 1)
    if(tip.adj < 0.5) tip.xlim[1] <- -tip.adj / 0.5
    if(tip.adj > 0.5) tip.xlim[2] <- -2 * tip.adj + 2
    plot.window(xlim = tip.xlim, ylim = ylim)
    text(x = 0, y = 1:n.tips, labels = tip.labels,
         adj = tip.adj, col = tip.col, cex = tip.cex, font = tip.font)
    fig.tip <- par("fig")
  } else {
    fig.tip <- NULL
    tip.xlim <- NULL
  }
  
  plot.phylo(phy, type = tree.type, show.tip.label = FALSE,
             x.lim = tree.xlim, y.lim = NULL,
             no.margin = FALSE, direction = "rightwards", ...)
  fig.tree <- par("fig")
  
  if(plot.type == "gridplot" & show.color.scale){
    par(new = TRUE)
    plt.init <- par("plt")
    par(plt = c(par("plt")[1] + 0.05, par("plt")[2] - 0.2, 0.07, 0.1))
    plot.new()
    breaks <- seq(min(X), max(X), length.out = (length(cell.col) + 1))
    scale.xlim <- range(breaks)
    scale.ylim <- c(0, 1)
    plot.window(xlim = scale.xlim, ylim = scale.ylim)
    for(i in 1:length(cell.col)){
      polygon(c(breaks[i], breaks[i + 1], breaks[i + 1], breaks[i]), c(0, 0, 1, 1),
              col = cell.col[i], border = NA)
    }
    axis(1)
    par(plt = plt.init)
  }
  
  assign("last_barplotp4d", list(plot.type = plot.type,
                                 show.tip = show.tip,
                                 layout = lay,
                                 fig.tree = fig.tree,
                                 fig.traits = fig.traits,
                                 fig.tip = fig.tip,
                                 tree.xlim = tree.xlim,
                                 bar.xlim = bar.xlim,
                                 tip.xlim = tip.xlim,
                                 ylim = ylim, par.mar0 = par.mar0), 
         envir = .PlotPhyloEnv)
  layout(1)
  par(mar = par.mar0)
  invisible()
}



#' Focus on sub parts of a plot
#'
#' These functions can be used after barplot.phylo4d to focus on
#' the different part of the plot and add graphical elements.
#' 
#' @param x the trait to focus on.
#' Can be a character string giving the name of the trait or an integer giving
#' the number of the trait in order of appearance in the plot.
#' 
#' @details #' Use \code{focusTree} to focus on the phylogenetic tree, \code{focusTraits}
#' to focus on a given trait and \code{focusTips} to focus on the tips labels.
#' Use \code{focusStop} to close the editing and restore graphical settings.
#' For each part of the plot, the coordinate system is restored, making edition easier.
#' For the phylogeny, post-editing functions of the package \code{ape} like \code{nodelabels} can be used.
#'
#'@rdname focus
#'@export
focusTraits <- function(x){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  if(lp$plot.type == "gridplot"){
    x <- 1
  }
  par(new = TRUE)
  plot.new()
  layout(lp$layout)
  par(mar = c(5, 1, 4, 0))
  fig <- unlist(lp$fig.traits[x])
  par(fig = fig)
  plot.window(xlim = lp$bar.xlim[, x], ylim = lp$ylim)
}

#'@rdname focus
#'@export
focusTree <- function(){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  par(new = TRUE)
  plot.new()
  layout(lp$layout)
  par(mar = c(5, 1, 4, 0))
  fig <- unlist(lp$fig.tree)
  par(fig = fig)
  plot.window(xlim = lp$tree.xlim, ylim = lp$ylim)
}

#'@rdname focus
#'@export
focusTips <- function(){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  if(!lp$show.tip){
    stop("No tip labels on the figure")
  } else {
    par(new = TRUE)
    plot.new()
    layout(lp$layout)
    par(mar = c(5, 1, 4, 0))
    fig <- unlist(lp$fig.tip)
    par(fig = fig)
    plot.window(xlim = lp$tip.xlim, ylim = lp$ylim)
  }
}

#'@rdname focus
#'@export
focusStop <- function(){
  lp <- get("last_barplotp4d", envir = .PlotPhyloEnv)
  layout(1)
  par(mar = lp$par.mar0)
}

#' Plot p4d Object
#'@export
#'@rdname plotp4d
barplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE, ...){
  
  multiplot.phylo4d(p4d, trait = trait, center = center, scale = scale, plot.type = "barplot", ...)
  
}


#'@rdname plotp4d
dotplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE,
                            grid.horizontal = TRUE, grid.vertical = FALSE, ...){
  
  multiplot.phylo4d(p4d, trait = trait, center = center, scale = scale, plot.type = "dotplot",
                    grid.horizontal = grid.horizontal, grid.vertical = grid.vertical, ...)
  
}


#'@rdname plotp4d
gridplot <- function(...){
  UseMethod("gridplot")
}
gridplot.phylo4d <- function(p4d, trait = names(tdata(p4d)), center = TRUE, scale = TRUE,
                     grid.vertical = FALSE, trait.cex = 0.7, ...){
  
  multiplot.phylo4d(p4d, trait = trait, center = center, scale = scale, plot.type = "gridplot",
                    trait.cex = trait.cex, grid.vertical = grid.vertical, ...)
  
}


#    barplot(p4d, c("random","bm"), show.tip=T, tip.col=c(2,1), tip.cex=0.8, tip.font=1, tip.adj=0.5,
#   trait.col=c(2,3), trait.cex=0.8, trait.font=2, trait.bg.col="grey95" , error.bar.inf=mat.e, error.bar.sup=mat.e)

#    barplot(p4d, bar.col=matrix(c(rainbow(19), terrain.colors(19), heat.colors(19))))

#barplot(p4d, error.bar.inf=mat.e)

# mat.e <- matrix(abs(rnorm(19*3, 0, 0.5)), ncol=3, dimnames=list(tipLabels(p4d), names(tdata(p4d))))

# barplot(p4d, trait.bg.col = c("#F6CED8", "#CED8F6", "#CEF6CE"), bar.col = mat.col, tip.col=tip.col,
# grid.col=1:3, edge.width=2, lend=3, show.bar.axis=T, grid.horizontal=T, scale=F)
# focusTraits("random")
# points(0, 13, col =2, pch=20, cex=4)
# focusTips()
# points(0, 2, col= 3, cex= 3)
# abline(v=0.5, col=4)
# focusTree()
# points(2,3)
# nodelabels()
# focusStop()
# plot(1)